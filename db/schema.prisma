// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

// unique links by /profile/[address]
// unique links by /profile/discord/[discordId]
model Account {
  id                Int                @id @default(autoincrement())
  address           String?            @unique
  discordId         String?            @unique
  addressType       AddressType?
  data              Json?
  createdAt         DateTime?          @default(now())
  updatedAt         DateTime?          @updatedAt
  tickets           AccountTerminal[]
  sessions          Session[]
  // proposals Account is a collaborator of, generated by linter
  proposals         AccountProposal[]
  proposalNews      ProposalRole[]
  // rfps Account is an author of, generated by linter
  rfps              Rfp[]
  // approvals Account has signed, generated by linter
  checkApprovals    CheckApproval[]
  proposalApprovals ProposalApproval[]

  // v1
  skills             AccountSkill[]
  initiatives        AccountInitiative[]
  endorsed           Endorsement[]       @relation("Endorsed")
  emailVerifications EmailVerification[]
  tokens             AccountToken[]
  originsOf          AccountAccount[]    @relation("origin")
  targetsOf          AccountAccount[]    @relation("target")
}

model EmailVerification {
  code      String  @id @default(uuid())
  accountId Int
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

// unique links by /station/[handle]
model Terminal {
  id         Int               @id @default(autoincrement())
  handle     String            @unique
  data       Json?
  members    AccountTerminal[]
  tags       Tag[]
  checkbooks Checkbook[]
  rfps       Rfp[]
  proposers  AccountProposal[]

  // v1
  ticketAddress String?      @unique
  initiatives   Initiative[]
  roles         Role[]
}

model AccountTerminal {
  account     Account              @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId   Int
  terminal    Terminal             @relation(fields: [terminalId], references: [id])
  terminalId  Int
  joinedAt    DateTime             @default(now())
  tags        AccountTerminalTag[]
  data        Json?
  // v1
  active      Boolean              @default(true)
  roleLocalId Int?
  role        Role?                @relation(fields: [terminalId, roleLocalId], references: [terminalId, localId])

  @@id([accountId, terminalId])
}

model AccountToken {
  account      Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    Int
  token        Token   @relation(fields: [tokenAddress, chainId], references: [address, chainId])
  tokenAddress String
  chainId      Int
  data         Json?

  @@id([accountId, tokenAddress, chainId])
}

model Tag {
  id         Int                  @id @default(autoincrement())
  type       String
  value      String
  active     Boolean              @default(true)
  terminal   Terminal             @relation(fields: [terminalId], references: [id])
  terminalId Int
  discordId  String?
  data       Json?
  tickets    AccountTerminalTag[]

  @@unique([value, terminalId])
}

model AccountTerminalTag {
  tag              Tag             @relation(fields: [tagId], references: [id])
  tagId            Int
  ticket           AccountTerminal @relation(fields: [ticketAccountId, ticketTerminalId], references: [accountId, terminalId], onDelete: Cascade)
  ticketAccountId  Int
  ticketTerminalId Int

  @@id([tagId, ticketAccountId, ticketTerminalId])
}

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?
  userId             Int?
  user               Account?  @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Checkbook {
  address    String   @id
  chainId    Int
  name       String
  terminalId Int
  terminal   Terminal @relation(fields: [terminalId], references: [id])
  quorum     Int
  signers    String[]
  data       Json
  checks     Check[]
  rfps       Rfp[]
}

// unique links by /station/handle]/rfp/[localId]
model Rfp {
  id             String     @id @default(uuid())
  terminalId     Int
  terminal       Terminal   @relation(fields: [terminalId], references: [id])
  fundingAddress String?
  checkbook      Checkbook? @relation(fields: [fundingAddress], references: [address])
  authorAddress  String
  author         Account?   @relation(fields: [authorAddress], references: [address])
  startDate      DateTime
  endDate        DateTime?
  status         RfpStatus  @default(DRAFT)
  data           Json
  proposals      Proposal[]
}

// unique links by /station/handle]/proposal/[localId]
model Proposal {
  id            String             @id @default(uuid())
  rfpId         String
  rfp           Rfp                @relation(fields: [rfpId], references: [id])
  status        ProposalStatus     @default(PUBLISHED)
  data          Json
  createdAt     DateTime           @default(now())
  collaborators AccountProposal[]
  checks        Check[]
  approvals     ProposalApproval[]
}

model AccountProposal {
  id         Int      @id @default(autoincrement())
  address    String
  account    Account? @relation(fields: [address], references: [address])
  terminalId Int
  terminal   Terminal @relation(fields: [terminalId], references: [id])
  proposalId String
  proposal   Proposal @relation(fields: [proposalId], references: [id])
}

model ProposalApproval {
  id            String   @id @default(uuid())
  proposalId    String
  proposal      Proposal @relation(fields: [proposalId], references: [id])
  signerAddress String
  signerAccount Account  @relation(fields: [signerAddress], references: [address])
  createdAt     DateTime @default(now())
  data          Json // { signature: string } // same signature as checkApproval

  @@unique([proposalId, signerAddress])
}

model Check {
  id               String          @id @default(uuid())
  proposalId       String
  proposal         Proposal        @relation(fields: [proposalId], references: [id])
  fundingAddress   String
  chainId          Int
  checkbook        Checkbook       @relation(fields: [fundingAddress], references: [address])
  recipientAddress String
  tokenAddress     String
  // refer to note in db/README.md
  tokenAmount      Decimal
  // timestamp needs to be converted to a unix representation in approval signatures
  deadline         DateTime
  nonce            Int
  // transaction hash of cashed check, marks status as "CASHED" if not null
  txnHash          String?
  data             Json
  approvals        CheckApproval[]

  // nonces are unique per checkbook to prevent re-cashing of the same check
  @@unique([fundingAddress, nonce])
}

model CheckApproval {
  id            String   @id @default(uuid())
  checkId       String
  check         Check    @relation(fields: [checkId], references: [id])
  signerAddress String
  signerAccount Account  @relation(fields: [signerAddress], references: [address])
  createdAt     DateTime @default(now())
  data          Json

  // prevent duplicate approvals for the same check
  @@unique([checkId, signerAddress])
}

model FeatureFlag {
  id          Int               @id @default(autoincrement())
  key         String            @unique
  title       String
  description String?
  status      FeatureFlagStatus @default(OFF)
  createdAt   DateTime          @default(now())
}

model ProposalNew {
  id         String              @id @default(uuid())
  type       ProposalType
  timestamp  DateTime            @default(now())
  data       Json
  status     ProposalNewStatus   @default(DRAFT)
  startDate  DateTime?
  endDate    DateTime?
  roles      ProposalRole[]
  milestones ProposalMilestone[]
  payments   ProposalPayment[]
  signatures ProposalSignature[]
}

model ProposalSignature {
  proposalId String
  proposal   ProposalNew @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  address    String
  timestamp  DateTime    @default(now())
  data       Json

  @@id([proposalId, address])
}

model ProposalRole {
  id         String           @id @default(uuid())
  proposalId String
  proposal   ProposalNew      @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  address    String
  account    Account          @relation(fields: [address], references: [address])
  role       ProposalRoleType
}

model Token {
  address  String
  type     TokenType
  chainId  Int
  name     String?
  symbol   String?
  decimals Int?
  accounts AccountToken[]

  @@id([address, chainId])
}

model ProposalMilestone {
  proposalId String
  proposal   ProposalNew @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  index      Int
  data       Json

  payments ProposalPayment[]
  @@id([proposalId, index])
}

model ProposalPayment {
  id               String            @id @default(uuid())
  proposalId       String
  proposal         ProposalNew       @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  milestoneIndex   Int
  milestone        ProposalMilestone @relation(fields: [proposalId, milestoneIndex], references: [proposalId, index])
  senderAddress    String
  recipientAddress String
  amount           Float? // float to support larger size numbers
  tokenId          Float? // float to support larger size numbers
  transactionHash  String?
  data             Json
}

model AccountAccount {
  id            String             @id @default(uuid())
  originAddress String
  targetAddress String
  originAccount Account            @relation("origin", fields: [originAddress], references: [address])
  targetAccount Account            @relation("target", fields: [targetAddress], references: [address])
  type          AccountAccountType
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  data          Json

  @@unique([originAddress, targetAddress, type])
}

enum AccountAccountType {
  PIN_WORKSPACE
}

enum TokenType {
  COIN // Native chain's gas token
  ERC20
  ERC721
  ERC1155
}

enum FeatureFlagStatus {
  OFF
  ON
}

enum AddressType {
  WALLET
  SAFE
  CHECKBOOK
}

enum ProposalType {
  FUNDING
}

enum ProposalRoleType {
  AUTHOR
  CONTRIBUTOR
  CLIENT
}

enum RfpStatus {
  DRAFT
  PUBLISHED
  DELETED
}

enum ProposalStatus {
  DRAFT
  PUBLISHED
  IN_REVIEW
  APPROVED
  DELETED
}

enum ProposalNewStatus {
  DRAFT
  AWAITING_APPROVAL
  APPROVED
  COMPLETE
}

//
//  V1 Models -- no longer used
//

// A role within a terminal
model Role {
  terminal   Terminal          @relation(fields: [terminalId], references: [id])
  terminalId Int
  localId    Int               @default(autoincrement())
  tickets    AccountTerminal[]
  data       Json?

  @@id([terminalId, localId])
}

// An initiative within a terminal
model Initiative {
  id         Int                 @id @default(autoincrement())
  terminal   Terminal            @relation(fields: [terminalId], references: [id])
  terminalId Int
  localId    Int                 @default(autoincrement())
  accounts   AccountInitiative[]
  skills     InitiativeSkill[]
  data       Json?

  @@unique([terminalId, localId])
}

// deprecated
// Associates accounts with initiatives for applications and contributor membership
model AccountInitiative {
  account      Account                 @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    Int
  initiative   Initiative              @relation(fields: [initiativeId], references: [id])
  initiativeId Int
  createdAt    DateTime                @default(now())
  status       AccountInitiativeStatus @default(INTERESTED)
  data         Json?

  @@id([accountId, initiativeId])
}

enum AccountInitiativeStatus {
  INTERESTED
  CONTRIBUTING
  PREVIOUSLY_CONTRIBUTED
}

model Skill {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  accounts    AccountSkill[]
  initiatives InitiativeSkill[]
}

model AccountSkill {
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId Int
  skill     Skill   @relation(fields: [skillId], references: [id])
  skillId   Int

  @@id([accountId, skillId])
}

// deprecated
model InitiativeSkill {
  initiative   Initiative @relation(fields: [initiativeId], references: [id])
  initiativeId Int
  skill        Skill      @relation(fields: [skillId], references: [id])
  skillId      Int

  @@id([initiativeId, skillId])
}

model Endorsement {
  id               Int      @id @default(autoincrement())
  initiativeId     Int
  endorser         Account  @relation(name: "Endorsed", fields: [endorserId], references: [id], onDelete: Cascade)
  endorserId       Int
  endorseeId       Int
  timestamp        DateTime @default(now())
  endorsementValue Int
  data             Json?
}

//
// Don't write new models below here!
// This is the deprecated V1 models section
// Write new models above this section :)
//
