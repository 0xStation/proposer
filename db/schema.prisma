// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

model Account {
  id          Int          @id @default(autoincrement())
  address     String?      @unique
  discordId   String?      @unique
  addressType AddressType?
  data        Json?
  createdAt   DateTime?    @default(now())
  updatedAt   DateTime?    @updatedAt

  sessions          Session[]
  proposalNews      ProposalRole[]
  tokens            AccountToken[]
  originsOf         AccountAccount[]    @relation("origin")
  targetsOf         AccountAccount[]    @relation("target")
  EmailVerification EmailVerification[]
}

model EmailVerification {
  code      String  @id @default(uuid())
  accountId Int
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model AccountToken {
  account      Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    Int
  token        Token   @relation(fields: [tokenAddress, chainId], references: [address, chainId])
  tokenAddress String
  chainId      Int
  data         Json?

  @@id([accountId, tokenAddress, chainId])
}

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?
  userId             Int?
  user               Account?  @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model FeatureFlag {
  id          Int               @id @default(autoincrement())
  key         String            @unique
  title       String
  description String?
  status      FeatureFlagStatus @default(OFF)
  createdAt   DateTime          @default(now())
}

model ProposalNew {
  id                    String            @id @default(uuid())
  type                  ProposalType
  timestamp             DateTime          @default(now())
  currentMilestoneIndex Int               @default(-1) // no current milestone, gets set to 0 after proposal is approved
  data                  Json
  status                ProposalNewStatus @default(DRAFT)
  startDate             DateTime?
  endDate               DateTime?

  roles      ProposalRole[]
  milestones ProposalMilestone[]
  payments   ProposalPayment[]
  signatures ProposalSignature[]
}

model ProposalSignature {
  id         String      @id @default(uuid())
  proposalId String
  proposal   ProposalNew @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  address    String
  timestamp  DateTime    @default(now())
  data       Json

  // m-n relation to support one signature being utilized for many roles
  // for example, I can have the AUTHOR and CONTRIBUTOR role simultaneously
  // another example, I can be a AUTHOR and represent a CLIENT as a signer of its multisig
  roles ProposalRole[] @relation("RoleApprovalSignature")
}

model ProposalRole {
  id             String                     @id @default(uuid())
  proposalId     String
  proposal       ProposalNew                @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  address        String
  approvalStatus ProposalRoleApprovalStatus @default(INCOMPLETE)
  account        Account                    @relation(fields: [address], references: [address])
  role           ProposalRoleType

  // m-n relation to support one role containing multiple supporting signatures to reach COMPLETE approval status
  // for example, a multisig needs Q (quorum) signatures to approve by default
  // another example, a DAO using token voting needs a majority vote of at least Q (quorum) votes to approve
  signatures ProposalSignature[] @relation("RoleApprovalSignature")
}

model Token {
  address  String
  type     TokenType
  chainId  Int
  name     String?
  symbol   String?
  decimals Int?
  accounts AccountToken[]

  @@id([address, chainId])
}

model ProposalMilestone {
  id         String      @id @default(uuid())
  proposalId String
  proposal   ProposalNew @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  index      Int
  data       Json

  payments ProposalPayment[]
  @@unique([proposalId, index])
}

model ProposalPayment {
  id               String            @id @default(uuid())
  proposalId       String
  proposal         ProposalNew       @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  milestoneId      String
  milestone        ProposalMilestone @relation(fields: [milestoneId], references: [id])
  senderAddress    String
  recipientAddress String
  amount           Float? // float to support larger size numbers
  tokenId          Float? // float to support larger size numbers
  transactionHash  String?
  data             Json
}

model AccountAccount {
  id            String             @id @default(uuid())
  originAddress String
  targetAddress String
  originAccount Account            @relation("origin", fields: [originAddress], references: [address])
  targetAccount Account            @relation("target", fields: [targetAddress], references: [address])
  type          AccountAccountType
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  data          Json

  @@unique([originAddress, targetAddress, type])
}

enum ProposalRoleApprovalStatus {
  INCOMPLETE // approval is incomplete and accruing more signatures
  COMPLETE // approval is complete and has all the signatures it needs
}

enum AccountAccountType {
  PIN_WORKSPACE
}

enum TokenType {
  COIN // Native chain's gas token
  ERC20
  ERC721
  ERC1155
}

enum FeatureFlagStatus {
  OFF
  ON
}

enum AddressType {
  WALLET
  SAFE
  CHECKBOOK
}

enum ProposalType {
  FUNDING
}

enum ProposalRoleType {
  AUTHOR
  CONTRIBUTOR
  CLIENT
}

enum ProposalStatus {
  DRAFT
  PUBLISHED
  IN_REVIEW
  APPROVED
  DELETED
}

enum ProposalNewStatus {
  DRAFT
  AWAITING_APPROVAL
  APPROVED
  COMPLETE
}
