// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

// ACCOUNT SYSTEM

model Account {
  id          Int         @id @default(autoincrement())
  address     String      @unique
  discordId   String?
  addressType AddressType
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  data        Json

  sessions           Session[]
  rfps               Rfp[]
  proposals          ProposalRole[]
  tokens             AccountToken[]
  originsOf          AccountAccount[]    @relation("origin")
  targetsOf          AccountAccount[]    @relation("target")
  verificationEmails EmailVerification[]
  proposalTemplates  ProposalTemplate[]
  comments           Comment[]
}

enum AddressType {
  WALLET
  SAFE
}

model AccountAccount {
  id            String             @id @default(uuid())
  originAddress String
  targetAddress String
  type          AccountAccountType
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  data          Json

  originAccount Account @relation("origin", fields: [originAddress], references: [address], onDelete: Cascade)
  targetAccount Account @relation("target", fields: [targetAddress], references: [address], onDelete: Cascade)

  @@unique([originAddress, targetAddress, type])
}

enum AccountAccountType {
  PIN_WORKSPACE
}

// TEMPLATE

model ProposalTemplate {
  id             String   @id @default(uuid())
  accountAddress String
  chainId        Int? // used to query templates on the same chain
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  data           Json
  rfps           Rfp[]
  account        Account  @relation(fields: [accountAddress], references: [address])
}

// REQUESTS FOR PROPOSALS

model Rfp {
  id             String    @id @default(uuid())
  accountAddress String
  templateId     String?
  data           Json
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  status         RfpStatus @default(OPEN)

  account Account @relation(fields: [accountAddress], references: [address], onDelete: Cascade)

  proposals Proposal[]
  template  ProposalTemplate? @relation(fields: [templateId], references: [id])
}

// used to manually open and close rfps
enum RfpStatus {
  OPEN
  CLOSED
  // TIME_DEPENDENT -- will be used to indicate rely on start/end times to render status
}

// PROPOSAL SYSTEM

model Proposal {
  id                    String         @id @default(uuid())
  rfpId                 String?
  status                ProposalStatus @default(DRAFT)
  timestamp             DateTime       @default(now())
  currentMilestoneIndex Int            @default(-1) // no current milestone, gets set to 0 after proposal is approved
  data                  Json
  suppress              Boolean        @default(false)

  rfp Rfp? @relation(fields: [rfpId], references: [id], onDelete: Cascade)

  roles      ProposalRole[]
  milestones ProposalMilestone[]
  payments   ProposalPayment[]
  signatures ProposalSignature[]
  comments   Comment[]
}

enum ProposalStatus {
  DRAFT
  AWAITING_APPROVAL
  APPROVED
  COMPLETE
}

// PROPOSAL ROLES

model ProposalRole {
  id             String                     @id @default(uuid())
  proposalId     String
  address        String
  type           ProposalRoleType
  approvalStatus ProposalRoleApprovalStatus @default(PENDING)

  account    Account             @relation(fields: [address], references: [address], onDelete: Cascade)
  proposal   Proposal            @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  // m-n relation to support one role containing multiple supporting signatures to reach COMPLETE approval status
  // for example, a multisig needs Q (quorum) signatures to approve by default
  // another example, a DAO using token voting needs a majority vote of at least Q (quorum) votes to approve
  signatures ProposalSignature[] @relation("RoleApprovalSignature")
}

enum ProposalRoleType {
  AUTHOR
  CONTRIBUTOR
  CLIENT
}

enum ProposalRoleApprovalStatus {
  PENDING // role is pending approval
  APPROVED // role has approved
  SENT // signed by author to send to recipientsgena
  // DENY - future for denying proposals
}

model ProposalSignature {
  id         String                @id @default(uuid())
  proposalId String
  address    String
  timestamp  DateTime              @default(now())
  data       Json
  type       ProposalSignatureType @default(APPROVE)

  proposal Proposal       @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  // m-n relation to support one signature being utilized for many roles
  // for example, I can have the AUTHOR and CONTRIBUTOR role simultaneously
  // another example, I can be a AUTHOR and represent a CLIENT as a signer of its multisig
  roles    ProposalRole[] @relation("RoleApprovalSignature")
}

enum ProposalSignatureType {
  APPROVE // approving the proposal
  SEND // send the proposal to other roles as an author
}

// PROPOSAL MILESTONES AND EXPECTATIONS

model ProposalMilestone {
  id         String @id @default(uuid())
  proposalId String
  index      Int
  data       Json

  proposal Proposal          @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  payments ProposalPayment[]
  @@unique([proposalId, index])
}

model ProposalPayment {
  id               String  @id @default(uuid())
  proposalId       String
  milestoneId      String
  senderAddress    String
  recipientAddress String
  amount           Float? // float to support larger size numbers
  tokenId          Float? // float to support larger size numbers
  transactionHash  String?
  data             Json

  proposal  Proposal          @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  milestone ProposalMilestone @relation(fields: [milestoneId], references: [id])
}

// SESSION MANAGEMENT

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?
  userId             Int?

  user Account? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// TOKENS

model Token {
  address  String
  type     TokenType
  chainId  Int
  name     String?
  symbol   String?
  decimals Int?

  accounts AccountToken[]
  @@id([address, chainId])
}

enum TokenType {
  COIN // Native chain's gas token
  ERC20
  ERC721
  ERC1155
}

model AccountToken {
  accountId    Int
  tokenAddress String
  chainId      Int
  data         Json?

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  token   Token   @relation(fields: [tokenAddress, chainId], references: [address, chainId])
  @@id([accountId, tokenAddress, chainId])
}

// FEATURE FLAGS

model FeatureFlag {
  id          Int               @id @default(autoincrement())
  key         String            @unique
  title       String
  description String?
  status      FeatureFlagStatus @default(OFF)
  createdAt   DateTime          @default(now())
}

enum FeatureFlagStatus {
  OFF
  ON
}

// EMAIL

model EmailVerification {
  code      String @id @default(uuid())
  accountId Int

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

// COMMENT

// can expand these later
enum FieldKey {
  ROLES
}

model Comment {
  id            String    @id @default(uuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  data          Json?
  fieldKey      FieldKey?
  children      Comment[] @relation("Comment_Children")
  parent        Comment?  @relation("Comment_Children", fields: [parentId], references: [id])
  parentId      String?
  proposal      Proposal  @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId    String
  author        Account   @relation(fields: [authorAddress], references: [address], onDelete: Cascade)
  authorAddress String
}
