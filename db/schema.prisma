// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

// ACCOUNT SYSTEM

model Account {
  id          Int         @id @default(autoincrement())
  address     String      @unique
  addressType AddressType
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  data        Json

  sessions           Session[]
  proposals          ProposalRole[]
  tokens             AccountToken[]
  originsOf          AccountAccount[]    @relation("origin")
  targetsOf          AccountAccount[]    @relation("target")
  verificationEmails EmailVerification[]
}

enum AddressType {
  WALLET
  SAFE
}

model AccountAccount {
  id            String             @id @default(uuid())
  originAddress String
  targetAddress String
  type          AccountAccountType
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  data          Json

  originAccount Account @relation("origin", fields: [originAddress], references: [address], onDelete: Cascade)
  targetAccount Account @relation("target", fields: [targetAddress], references: [address], onDelete: Cascade)

  @@unique([originAddress, targetAddress, type])
}

enum AccountAccountType {
  PIN_WORKSPACE
}

// PROPOSAL SYSTEM

model Proposal {
  id                    String         @id @default(uuid())
  status                ProposalStatus @default(DRAFT)
  timestamp             DateTime       @default(now())
  currentMilestoneIndex Int            @default(-1) // no current milestone, gets set to 0 after proposal is approved
  data                  Json

  roles      ProposalRole[]
  milestones ProposalMilestone[]
  payments   ProposalPayment[]
  signatures ProposalSignature[]
}

enum ProposalStatus {
  DRAFT
  AWAITING_APPROVAL
  APPROVED
  COMPLETE
}

// PROPOSAL ROLES

model ProposalRole {
  id             String                     @id @default(uuid())
  proposalId     String
  address        String
  type           ProposalRoleType
  approvalStatus ProposalRoleApprovalStatus @default(PENDING)

  account    Account             @relation(fields: [address], references: [address], onDelete: Cascade)
  proposal   Proposal            @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  // m-n relation to support one role containing multiple supporting signatures to reach COMPLETE approval status
  // for example, a multisig needs Q (quorum) signatures to approve by default
  // another example, a DAO using token voting needs a majority vote of at least Q (quorum) votes to approve
  signatures ProposalSignature[] @relation("RoleApprovalSignature")
}

enum ProposalRoleType {
  AUTHOR
  CONTRIBUTOR
  CLIENT
}

enum ProposalRoleApprovalStatus {
  PENDING // role is pending approval
  APPROVED // role has approved
  SENT // signed by author to send to recipientsgena
  AWAITING_AUTHOR // NOT used in db, just here for the enum option on frontend because you cannot inherit/extend an enum
  // DENY -- future for denying proposals
}

model ProposalSignature {
  id         String                @id @default(uuid())
  proposalId String
  address    String
  timestamp  DateTime              @default(now())
  data       Json
  type       ProposalSignatureType @default(APPROVE)

  proposal Proposal       @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  // m-n relation to support one signature being utilized for many roles
  // for example, I can have the AUTHOR and CONTRIBUTOR role simultaneously
  // another example, I can be a AUTHOR and represent a CLIENT as a signer of its multisig
  roles    ProposalRole[] @relation("RoleApprovalSignature")
}

enum ProposalSignatureType {
  APPROVE // approving the proposal
  SEND // send the proposal to other roles as an author
}

// PROPOSAL MILESTONES AND EXPECTATIONS

model ProposalMilestone {
  id         String @id @default(uuid())
  proposalId String
  index      Int
  data       Json

  proposal Proposal          @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  payments ProposalPayment[]
  @@unique([proposalId, index])
}

model ProposalPayment {
  id               String  @id @default(uuid())
  proposalId       String
  milestoneId      String
  senderAddress    String
  recipientAddress String
  amount           Float? // float to support larger size numbers
  tokenId          Float? // float to support larger size numbers
  transactionHash  String?
  data             Json

  proposal  Proposal          @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  milestone ProposalMilestone @relation(fields: [milestoneId], references: [id])
}

// SESSION MANAGEMENT

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?
  userId             Int?

  user Account? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// TOKENS

model Token {
  address  String
  type     TokenType
  chainId  Int
  name     String?
  symbol   String?
  decimals Int?

  accounts AccountToken[]
  @@id([address, chainId])
}

enum TokenType {
  COIN // Native chain's gas token
  ERC20
  ERC721
  ERC1155
}

model AccountToken {
  accountId    Int
  tokenAddress String
  chainId      Int
  data         Json?

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  token   Token   @relation(fields: [tokenAddress, chainId], references: [address, chainId])
  @@id([accountId, tokenAddress, chainId])
}

// FEATURE FLAGS

model FeatureFlag {
  id          Int               @id @default(autoincrement())
  key         String            @unique
  title       String
  description String?
  status      FeatureFlagStatus @default(OFF)
  createdAt   DateTime          @default(now())
}

enum FeatureFlagStatus {
  OFF
  ON
}

// EMAIL

model EmailVerification {
  code      String @id @default(uuid())
  accountId Int

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}
